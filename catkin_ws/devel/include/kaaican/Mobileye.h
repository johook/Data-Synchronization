// Generated by gencpp from file kaaican/Mobileye.msg
// DO NOT EDIT!


#ifndef KAAICAN_MESSAGE_MOBILEYE_H
#define KAAICAN_MESSAGE_MOBILEYE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace kaaican
{
template <class ContainerAllocator>
struct Mobileye_
{
  typedef Mobileye_<ContainerAllocator> Type;

  Mobileye_()
    : mobileye_can_message_number(0)
    , msg_count(0)
    , msg_status(0)
    , tosec(0.0)
    , time(0)
    , Con_Left(0)
    , LDW_Left(0)
    , Type_Left(0)
    , Dis_Left(0.0)
    , Con_Right(0)
    , LDW_Right(0)
    , Type_Right(0)
    , Dis_Right(0.0)
    , Head_Valid(0)
    , Head_Mea(0.0)
    , LDW_OFF(0)
    , LDW_Left_On(0)
    , LDW_Right_On(0)
    , FCW_On(0)
    , Left_Crossing_Event(0)
    , Right_Crossing_Event(0)
    , P_FCW(0)
    , P_DZ(0)
    , TSR_En(0)
    , TSR_W_Lv(0)
    , Head_W_Lv(0)
    , HW_R_En(0)
    , Sign1(0)
    , Sign2(0)
    , Sign3(0)
    , Sign4(0)
    , S_Sign1(0)
    , S_Sign2(0)
    , S_Sign3(0)
    , S_Sign4(0)
    , HLB_dec(0)
    , L_Beam(0)
    , L_Cur(0.0)
    , L_Head(0.0)
    , Con_Area(0)
    , R_LDW(0)
    , L_LDW(0)
    , Yaw(0.0)
    , Pitch(0.0)
    , Num_O(0)
    , Timestamp(0)
    , L_Close(0)
    , R_Close(0)
    , GO(0)
    , Close_Car(0)
    , L_Signal(0)
    , R_Signal(0)
    , Wiper(0)
    , Lo_Beam(0)
    , Hi_Beam(0)
    , Speed(0)
    , Sign_Type(0)
    , S_Sign_Type(0)
    , Sign_X(0.0)
    , Sign_Y(0.0)
    , Sign_Z(0.0)
    , Filter_Type(0)  {
    }
  Mobileye_(const ContainerAllocator& _alloc)
    : mobileye_can_message_number(0)
    , msg_count(0)
    , msg_status(0)
    , tosec(0.0)
    , time(0)
    , Con_Left(0)
    , LDW_Left(0)
    , Type_Left(0)
    , Dis_Left(0.0)
    , Con_Right(0)
    , LDW_Right(0)
    , Type_Right(0)
    , Dis_Right(0.0)
    , Head_Valid(0)
    , Head_Mea(0.0)
    , LDW_OFF(0)
    , LDW_Left_On(0)
    , LDW_Right_On(0)
    , FCW_On(0)
    , Left_Crossing_Event(0)
    , Right_Crossing_Event(0)
    , P_FCW(0)
    , P_DZ(0)
    , TSR_En(0)
    , TSR_W_Lv(0)
    , Head_W_Lv(0)
    , HW_R_En(0)
    , Sign1(0)
    , Sign2(0)
    , Sign3(0)
    , Sign4(0)
    , S_Sign1(0)
    , S_Sign2(0)
    , S_Sign3(0)
    , S_Sign4(0)
    , HLB_dec(0)
    , L_Beam(0)
    , L_Cur(0.0)
    , L_Head(0.0)
    , Con_Area(0)
    , R_LDW(0)
    , L_LDW(0)
    , Yaw(0.0)
    , Pitch(0.0)
    , Num_O(0)
    , Timestamp(0)
    , L_Close(0)
    , R_Close(0)
    , GO(0)
    , Close_Car(0)
    , L_Signal(0)
    , R_Signal(0)
    , Wiper(0)
    , Lo_Beam(0)
    , Hi_Beam(0)
    , Speed(0)
    , Sign_Type(0)
    , S_Sign_Type(0)
    , Sign_X(0.0)
    , Sign_Y(0.0)
    , Sign_Z(0.0)
    , Filter_Type(0)  {
  (void)_alloc;
    }



   typedef uint32_t _mobileye_can_message_number_type;
  _mobileye_can_message_number_type mobileye_can_message_number;

   typedef uint32_t _msg_count_type;
  _msg_count_type msg_count;

   typedef uint32_t _msg_status_type;
  _msg_status_type msg_status;

   typedef double _tosec_type;
  _tosec_type tosec;

   typedef uint32_t _time_type;
  _time_type time;

   typedef uint32_t _Con_Left_type;
  _Con_Left_type Con_Left;

   typedef uint32_t _LDW_Left_type;
  _LDW_Left_type LDW_Left;

   typedef uint32_t _Type_Left_type;
  _Type_Left_type Type_Left;

   typedef double _Dis_Left_type;
  _Dis_Left_type Dis_Left;

   typedef uint32_t _Con_Right_type;
  _Con_Right_type Con_Right;

   typedef uint32_t _LDW_Right_type;
  _LDW_Right_type LDW_Right;

   typedef uint32_t _Type_Right_type;
  _Type_Right_type Type_Right;

   typedef double _Dis_Right_type;
  _Dis_Right_type Dis_Right;

   typedef uint32_t _Head_Valid_type;
  _Head_Valid_type Head_Valid;

   typedef double _Head_Mea_type;
  _Head_Mea_type Head_Mea;

   typedef uint32_t _LDW_OFF_type;
  _LDW_OFF_type LDW_OFF;

   typedef uint32_t _LDW_Left_On_type;
  _LDW_Left_On_type LDW_Left_On;

   typedef uint32_t _LDW_Right_On_type;
  _LDW_Right_On_type LDW_Right_On;

   typedef uint32_t _FCW_On_type;
  _FCW_On_type FCW_On;

   typedef uint32_t _Left_Crossing_Event_type;
  _Left_Crossing_Event_type Left_Crossing_Event;

   typedef uint32_t _Right_Crossing_Event_type;
  _Right_Crossing_Event_type Right_Crossing_Event;

   typedef uint32_t _P_FCW_type;
  _P_FCW_type P_FCW;

   typedef uint32_t _P_DZ_type;
  _P_DZ_type P_DZ;

   typedef uint32_t _TSR_En_type;
  _TSR_En_type TSR_En;

   typedef uint32_t _TSR_W_Lv_type;
  _TSR_W_Lv_type TSR_W_Lv;

   typedef uint32_t _Head_W_Lv_type;
  _Head_W_Lv_type Head_W_Lv;

   typedef uint32_t _HW_R_En_type;
  _HW_R_En_type HW_R_En;

   typedef uint32_t _Sign1_type;
  _Sign1_type Sign1;

   typedef uint32_t _Sign2_type;
  _Sign2_type Sign2;

   typedef uint32_t _Sign3_type;
  _Sign3_type Sign3;

   typedef uint32_t _Sign4_type;
  _Sign4_type Sign4;

   typedef uint32_t _S_Sign1_type;
  _S_Sign1_type S_Sign1;

   typedef uint32_t _S_Sign2_type;
  _S_Sign2_type S_Sign2;

   typedef uint32_t _S_Sign3_type;
  _S_Sign3_type S_Sign3;

   typedef uint32_t _S_Sign4_type;
  _S_Sign4_type S_Sign4;

   typedef uint32_t _HLB_dec_type;
  _HLB_dec_type HLB_dec;

   typedef uint32_t _L_Beam_type;
  _L_Beam_type L_Beam;

   typedef double _L_Cur_type;
  _L_Cur_type L_Cur;

   typedef double _L_Head_type;
  _L_Head_type L_Head;

   typedef uint32_t _Con_Area_type;
  _Con_Area_type Con_Area;

   typedef uint32_t _R_LDW_type;
  _R_LDW_type R_LDW;

   typedef uint32_t _L_LDW_type;
  _L_LDW_type L_LDW;

   typedef double _Yaw_type;
  _Yaw_type Yaw;

   typedef double _Pitch_type;
  _Pitch_type Pitch;

   typedef uint32_t _Num_O_type;
  _Num_O_type Num_O;

   typedef uint32_t _Timestamp_type;
  _Timestamp_type Timestamp;

   typedef uint32_t _L_Close_type;
  _L_Close_type L_Close;

   typedef uint32_t _R_Close_type;
  _R_Close_type R_Close;

   typedef uint32_t _GO_type;
  _GO_type GO;

   typedef uint32_t _Close_Car_type;
  _Close_Car_type Close_Car;

   typedef uint32_t _L_Signal_type;
  _L_Signal_type L_Signal;

   typedef uint32_t _R_Signal_type;
  _R_Signal_type R_Signal;

   typedef uint32_t _Wiper_type;
  _Wiper_type Wiper;

   typedef uint32_t _Lo_Beam_type;
  _Lo_Beam_type Lo_Beam;

   typedef uint32_t _Hi_Beam_type;
  _Hi_Beam_type Hi_Beam;

   typedef uint32_t _Speed_type;
  _Speed_type Speed;

   typedef uint32_t _Sign_Type_type;
  _Sign_Type_type Sign_Type;

   typedef uint32_t _S_Sign_Type_type;
  _S_Sign_Type_type S_Sign_Type;

   typedef double _Sign_X_type;
  _Sign_X_type Sign_X;

   typedef double _Sign_Y_type;
  _Sign_Y_type Sign_Y;

   typedef double _Sign_Z_type;
  _Sign_Z_type Sign_Z;

   typedef uint32_t _Filter_Type_type;
  _Filter_Type_type Filter_Type;





  typedef boost::shared_ptr< ::kaaican::Mobileye_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::kaaican::Mobileye_<ContainerAllocator> const> ConstPtr;

}; // struct Mobileye_

typedef ::kaaican::Mobileye_<std::allocator<void> > Mobileye;

typedef boost::shared_ptr< ::kaaican::Mobileye > MobileyePtr;
typedef boost::shared_ptr< ::kaaican::Mobileye const> MobileyeConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::kaaican::Mobileye_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::kaaican::Mobileye_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::kaaican::Mobileye_<ContainerAllocator1> & lhs, const ::kaaican::Mobileye_<ContainerAllocator2> & rhs)
{
  return lhs.mobileye_can_message_number == rhs.mobileye_can_message_number &&
    lhs.msg_count == rhs.msg_count &&
    lhs.msg_status == rhs.msg_status &&
    lhs.tosec == rhs.tosec &&
    lhs.time == rhs.time &&
    lhs.Con_Left == rhs.Con_Left &&
    lhs.LDW_Left == rhs.LDW_Left &&
    lhs.Type_Left == rhs.Type_Left &&
    lhs.Dis_Left == rhs.Dis_Left &&
    lhs.Con_Right == rhs.Con_Right &&
    lhs.LDW_Right == rhs.LDW_Right &&
    lhs.Type_Right == rhs.Type_Right &&
    lhs.Dis_Right == rhs.Dis_Right &&
    lhs.Head_Valid == rhs.Head_Valid &&
    lhs.Head_Mea == rhs.Head_Mea &&
    lhs.LDW_OFF == rhs.LDW_OFF &&
    lhs.LDW_Left_On == rhs.LDW_Left_On &&
    lhs.LDW_Right_On == rhs.LDW_Right_On &&
    lhs.FCW_On == rhs.FCW_On &&
    lhs.Left_Crossing_Event == rhs.Left_Crossing_Event &&
    lhs.Right_Crossing_Event == rhs.Right_Crossing_Event &&
    lhs.P_FCW == rhs.P_FCW &&
    lhs.P_DZ == rhs.P_DZ &&
    lhs.TSR_En == rhs.TSR_En &&
    lhs.TSR_W_Lv == rhs.TSR_W_Lv &&
    lhs.Head_W_Lv == rhs.Head_W_Lv &&
    lhs.HW_R_En == rhs.HW_R_En &&
    lhs.Sign1 == rhs.Sign1 &&
    lhs.Sign2 == rhs.Sign2 &&
    lhs.Sign3 == rhs.Sign3 &&
    lhs.Sign4 == rhs.Sign4 &&
    lhs.S_Sign1 == rhs.S_Sign1 &&
    lhs.S_Sign2 == rhs.S_Sign2 &&
    lhs.S_Sign3 == rhs.S_Sign3 &&
    lhs.S_Sign4 == rhs.S_Sign4 &&
    lhs.HLB_dec == rhs.HLB_dec &&
    lhs.L_Beam == rhs.L_Beam &&
    lhs.L_Cur == rhs.L_Cur &&
    lhs.L_Head == rhs.L_Head &&
    lhs.Con_Area == rhs.Con_Area &&
    lhs.R_LDW == rhs.R_LDW &&
    lhs.L_LDW == rhs.L_LDW &&
    lhs.Yaw == rhs.Yaw &&
    lhs.Pitch == rhs.Pitch &&
    lhs.Num_O == rhs.Num_O &&
    lhs.Timestamp == rhs.Timestamp &&
    lhs.L_Close == rhs.L_Close &&
    lhs.R_Close == rhs.R_Close &&
    lhs.GO == rhs.GO &&
    lhs.Close_Car == rhs.Close_Car &&
    lhs.L_Signal == rhs.L_Signal &&
    lhs.R_Signal == rhs.R_Signal &&
    lhs.Wiper == rhs.Wiper &&
    lhs.Lo_Beam == rhs.Lo_Beam &&
    lhs.Hi_Beam == rhs.Hi_Beam &&
    lhs.Speed == rhs.Speed &&
    lhs.Sign_Type == rhs.Sign_Type &&
    lhs.S_Sign_Type == rhs.S_Sign_Type &&
    lhs.Sign_X == rhs.Sign_X &&
    lhs.Sign_Y == rhs.Sign_Y &&
    lhs.Sign_Z == rhs.Sign_Z &&
    lhs.Filter_Type == rhs.Filter_Type;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::kaaican::Mobileye_<ContainerAllocator1> & lhs, const ::kaaican::Mobileye_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace kaaican

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::kaaican::Mobileye_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::kaaican::Mobileye_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::kaaican::Mobileye_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::kaaican::Mobileye_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::kaaican::Mobileye_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::kaaican::Mobileye_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::kaaican::Mobileye_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8118d0bbcb6f43a7ca947d83e64e932b";
  }

  static const char* value(const ::kaaican::Mobileye_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8118d0bbcb6f43a7ULL;
  static const uint64_t static_value2 = 0xca947d83e64e932bULL;
};

template<class ContainerAllocator>
struct DataType< ::kaaican::Mobileye_<ContainerAllocator> >
{
  static const char* value()
  {
    return "kaaican/Mobileye";
  }

  static const char* value(const ::kaaican::Mobileye_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::kaaican::Mobileye_<ContainerAllocator> >
{
  static const char* value()
  {
    return "uint32 mobileye_can_message_number\n"
"uint32 msg_count\n"
"uint32 msg_status\n"
"float64 tosec\n"
"uint32 time\n"
"uint32 Con_Left\n"
"uint32 LDW_Left\n"
"uint32 Type_Left\n"
"float64 Dis_Left\n"
"uint32 Con_Right\n"
"uint32 LDW_Right\n"
"uint32 Type_Right\n"
"float64 Dis_Right\n"
"uint32 Head_Valid\n"
"float64 Head_Mea\n"
"uint32 LDW_OFF\n"
"uint32 LDW_Left_On\n"
"uint32 LDW_Right_On\n"
"uint32 FCW_On\n"
"uint32 Left_Crossing_Event\n"
"uint32 Right_Crossing_Event\n"
"uint32 P_FCW\n"
"uint32 P_DZ\n"
"uint32 TSR_En\n"
"uint32 TSR_W_Lv\n"
"uint32 Head_W_Lv\n"
"uint32 HW_R_En\n"
"uint32 Sign1\n"
"uint32 Sign2\n"
"uint32 Sign3\n"
"uint32 Sign4\n"
"uint32 S_Sign1\n"
"uint32 S_Sign2\n"
"uint32 S_Sign3\n"
"uint32 S_Sign4\n"
"uint32 HLB_dec\n"
"uint32 L_Beam\n"
"float64 L_Cur\n"
"float64 L_Head\n"
"uint32 Con_Area\n"
"uint32 R_LDW\n"
"uint32 L_LDW\n"
"float64 Yaw\n"
"float64 Pitch\n"
"uint32 Num_O\n"
"uint32 Timestamp\n"
"uint32 L_Close\n"
"uint32 R_Close\n"
"uint32 GO\n"
"uint32 Close_Car\n"
"uint32 L_Signal\n"
"uint32 R_Signal\n"
"uint32 Wiper\n"
"uint32 Lo_Beam\n"
"uint32 Hi_Beam\n"
"uint32 Speed\n"
"uint32 Sign_Type\n"
"uint32 S_Sign_Type\n"
"float64 Sign_X\n"
"float64 Sign_Y\n"
"float64 Sign_Z\n"
"uint32 Filter_Type\n"
;
  }

  static const char* value(const ::kaaican::Mobileye_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::kaaican::Mobileye_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.mobileye_can_message_number);
      stream.next(m.msg_count);
      stream.next(m.msg_status);
      stream.next(m.tosec);
      stream.next(m.time);
      stream.next(m.Con_Left);
      stream.next(m.LDW_Left);
      stream.next(m.Type_Left);
      stream.next(m.Dis_Left);
      stream.next(m.Con_Right);
      stream.next(m.LDW_Right);
      stream.next(m.Type_Right);
      stream.next(m.Dis_Right);
      stream.next(m.Head_Valid);
      stream.next(m.Head_Mea);
      stream.next(m.LDW_OFF);
      stream.next(m.LDW_Left_On);
      stream.next(m.LDW_Right_On);
      stream.next(m.FCW_On);
      stream.next(m.Left_Crossing_Event);
      stream.next(m.Right_Crossing_Event);
      stream.next(m.P_FCW);
      stream.next(m.P_DZ);
      stream.next(m.TSR_En);
      stream.next(m.TSR_W_Lv);
      stream.next(m.Head_W_Lv);
      stream.next(m.HW_R_En);
      stream.next(m.Sign1);
      stream.next(m.Sign2);
      stream.next(m.Sign3);
      stream.next(m.Sign4);
      stream.next(m.S_Sign1);
      stream.next(m.S_Sign2);
      stream.next(m.S_Sign3);
      stream.next(m.S_Sign4);
      stream.next(m.HLB_dec);
      stream.next(m.L_Beam);
      stream.next(m.L_Cur);
      stream.next(m.L_Head);
      stream.next(m.Con_Area);
      stream.next(m.R_LDW);
      stream.next(m.L_LDW);
      stream.next(m.Yaw);
      stream.next(m.Pitch);
      stream.next(m.Num_O);
      stream.next(m.Timestamp);
      stream.next(m.L_Close);
      stream.next(m.R_Close);
      stream.next(m.GO);
      stream.next(m.Close_Car);
      stream.next(m.L_Signal);
      stream.next(m.R_Signal);
      stream.next(m.Wiper);
      stream.next(m.Lo_Beam);
      stream.next(m.Hi_Beam);
      stream.next(m.Speed);
      stream.next(m.Sign_Type);
      stream.next(m.S_Sign_Type);
      stream.next(m.Sign_X);
      stream.next(m.Sign_Y);
      stream.next(m.Sign_Z);
      stream.next(m.Filter_Type);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Mobileye_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::kaaican::Mobileye_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::kaaican::Mobileye_<ContainerAllocator>& v)
  {
    s << indent << "mobileye_can_message_number: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mobileye_can_message_number);
    s << indent << "msg_count: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.msg_count);
    s << indent << "msg_status: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.msg_status);
    s << indent << "tosec: ";
    Printer<double>::stream(s, indent + "  ", v.tosec);
    s << indent << "time: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.time);
    s << indent << "Con_Left: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Con_Left);
    s << indent << "LDW_Left: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.LDW_Left);
    s << indent << "Type_Left: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Type_Left);
    s << indent << "Dis_Left: ";
    Printer<double>::stream(s, indent + "  ", v.Dis_Left);
    s << indent << "Con_Right: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Con_Right);
    s << indent << "LDW_Right: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.LDW_Right);
    s << indent << "Type_Right: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Type_Right);
    s << indent << "Dis_Right: ";
    Printer<double>::stream(s, indent + "  ", v.Dis_Right);
    s << indent << "Head_Valid: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Head_Valid);
    s << indent << "Head_Mea: ";
    Printer<double>::stream(s, indent + "  ", v.Head_Mea);
    s << indent << "LDW_OFF: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.LDW_OFF);
    s << indent << "LDW_Left_On: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.LDW_Left_On);
    s << indent << "LDW_Right_On: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.LDW_Right_On);
    s << indent << "FCW_On: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.FCW_On);
    s << indent << "Left_Crossing_Event: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Left_Crossing_Event);
    s << indent << "Right_Crossing_Event: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Right_Crossing_Event);
    s << indent << "P_FCW: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.P_FCW);
    s << indent << "P_DZ: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.P_DZ);
    s << indent << "TSR_En: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.TSR_En);
    s << indent << "TSR_W_Lv: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.TSR_W_Lv);
    s << indent << "Head_W_Lv: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Head_W_Lv);
    s << indent << "HW_R_En: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.HW_R_En);
    s << indent << "Sign1: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Sign1);
    s << indent << "Sign2: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Sign2);
    s << indent << "Sign3: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Sign3);
    s << indent << "Sign4: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Sign4);
    s << indent << "S_Sign1: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.S_Sign1);
    s << indent << "S_Sign2: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.S_Sign2);
    s << indent << "S_Sign3: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.S_Sign3);
    s << indent << "S_Sign4: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.S_Sign4);
    s << indent << "HLB_dec: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.HLB_dec);
    s << indent << "L_Beam: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.L_Beam);
    s << indent << "L_Cur: ";
    Printer<double>::stream(s, indent + "  ", v.L_Cur);
    s << indent << "L_Head: ";
    Printer<double>::stream(s, indent + "  ", v.L_Head);
    s << indent << "Con_Area: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Con_Area);
    s << indent << "R_LDW: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.R_LDW);
    s << indent << "L_LDW: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.L_LDW);
    s << indent << "Yaw: ";
    Printer<double>::stream(s, indent + "  ", v.Yaw);
    s << indent << "Pitch: ";
    Printer<double>::stream(s, indent + "  ", v.Pitch);
    s << indent << "Num_O: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Num_O);
    s << indent << "Timestamp: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Timestamp);
    s << indent << "L_Close: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.L_Close);
    s << indent << "R_Close: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.R_Close);
    s << indent << "GO: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.GO);
    s << indent << "Close_Car: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Close_Car);
    s << indent << "L_Signal: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.L_Signal);
    s << indent << "R_Signal: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.R_Signal);
    s << indent << "Wiper: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Wiper);
    s << indent << "Lo_Beam: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Lo_Beam);
    s << indent << "Hi_Beam: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Hi_Beam);
    s << indent << "Speed: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Speed);
    s << indent << "Sign_Type: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Sign_Type);
    s << indent << "S_Sign_Type: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.S_Sign_Type);
    s << indent << "Sign_X: ";
    Printer<double>::stream(s, indent + "  ", v.Sign_X);
    s << indent << "Sign_Y: ";
    Printer<double>::stream(s, indent + "  ", v.Sign_Y);
    s << indent << "Sign_Z: ";
    Printer<double>::stream(s, indent + "  ", v.Sign_Z);
    s << indent << "Filter_Type: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.Filter_Type);
  }
};

} // namespace message_operations
} // namespace ros

#endif // KAAICAN_MESSAGE_MOBILEYE_H
