// Generated by gencpp from file kaaican/can_std.msg
// DO NOT EDIT!


#ifndef KAAICAN_MESSAGE_CAN_STD_H
#define KAAICAN_MESSAGE_CAN_STD_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace kaaican
{
template <class ContainerAllocator>
struct can_std_
{
  typedef can_std_<ContainerAllocator> Type;

  can_std_()
    : tosec(0.0)
    , time(0)
    , count(0)
    , id(0)
    , len(0)
    , data()
    , status(0)
    , aa(0)
    , bb(0)
    , cc(0)
    , dd(0)
    , ee(0)
    , ff(0)
    , gg(0)
    , hh(0)
    , ii(0)
    , jj(0)
    , kk(0)
    , ll(0)
    , mm(0)
    , nn(0)
    , oo(0)
    , header()  {
    }
  can_std_(const ContainerAllocator& _alloc)
    : tosec(0.0)
    , time(0)
    , count(0)
    , id(0)
    , len(0)
    , data(_alloc)
    , status(0)
    , aa(0)
    , bb(0)
    , cc(0)
    , dd(0)
    , ee(0)
    , ff(0)
    , gg(0)
    , hh(0)
    , ii(0)
    , jj(0)
    , kk(0)
    , ll(0)
    , mm(0)
    , nn(0)
    , oo(0)
    , header(_alloc)  {
  (void)_alloc;
    }



   typedef double _tosec_type;
  _tosec_type tosec;

   typedef uint32_t _time_type;
  _time_type time;

   typedef uint32_t _count_type;
  _count_type count;

   typedef uint16_t _id_type;
  _id_type id;

   typedef uint8_t _len_type;
  _len_type len;

   typedef std::vector<uint16_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint16_t>> _data_type;
  _data_type data;

   typedef uint16_t _status_type;
  _status_type status;

   typedef uint16_t _aa_type;
  _aa_type aa;

   typedef uint16_t _bb_type;
  _bb_type bb;

   typedef uint16_t _cc_type;
  _cc_type cc;

   typedef uint16_t _dd_type;
  _dd_type dd;

   typedef uint16_t _ee_type;
  _ee_type ee;

   typedef uint16_t _ff_type;
  _ff_type ff;

   typedef uint16_t _gg_type;
  _gg_type gg;

   typedef uint16_t _hh_type;
  _hh_type hh;

   typedef uint16_t _ii_type;
  _ii_type ii;

   typedef uint16_t _jj_type;
  _jj_type jj;

   typedef uint16_t _kk_type;
  _kk_type kk;

   typedef uint16_t _ll_type;
  _ll_type ll;

   typedef uint16_t _mm_type;
  _mm_type mm;

   typedef uint16_t _nn_type;
  _nn_type nn;

   typedef uint16_t _oo_type;
  _oo_type oo;

   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;





  typedef boost::shared_ptr< ::kaaican::can_std_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::kaaican::can_std_<ContainerAllocator> const> ConstPtr;

}; // struct can_std_

typedef ::kaaican::can_std_<std::allocator<void> > can_std;

typedef boost::shared_ptr< ::kaaican::can_std > can_stdPtr;
typedef boost::shared_ptr< ::kaaican::can_std const> can_stdConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::kaaican::can_std_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::kaaican::can_std_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::kaaican::can_std_<ContainerAllocator1> & lhs, const ::kaaican::can_std_<ContainerAllocator2> & rhs)
{
  return lhs.tosec == rhs.tosec &&
    lhs.time == rhs.time &&
    lhs.count == rhs.count &&
    lhs.id == rhs.id &&
    lhs.len == rhs.len &&
    lhs.data == rhs.data &&
    lhs.status == rhs.status &&
    lhs.aa == rhs.aa &&
    lhs.bb == rhs.bb &&
    lhs.cc == rhs.cc &&
    lhs.dd == rhs.dd &&
    lhs.ee == rhs.ee &&
    lhs.ff == rhs.ff &&
    lhs.gg == rhs.gg &&
    lhs.hh == rhs.hh &&
    lhs.ii == rhs.ii &&
    lhs.jj == rhs.jj &&
    lhs.kk == rhs.kk &&
    lhs.ll == rhs.ll &&
    lhs.mm == rhs.mm &&
    lhs.nn == rhs.nn &&
    lhs.oo == rhs.oo &&
    lhs.header == rhs.header;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::kaaican::can_std_<ContainerAllocator1> & lhs, const ::kaaican::can_std_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace kaaican

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::kaaican::can_std_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::kaaican::can_std_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::kaaican::can_std_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::kaaican::can_std_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::kaaican::can_std_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::kaaican::can_std_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::kaaican::can_std_<ContainerAllocator> >
{
  static const char* value()
  {
    return "56b1a1065dc0e7a8c6d3bae792605a9c";
  }

  static const char* value(const ::kaaican::can_std_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x56b1a1065dc0e7a8ULL;
  static const uint64_t static_value2 = 0xc6d3bae792605a9cULL;
};

template<class ContainerAllocator>
struct DataType< ::kaaican::can_std_<ContainerAllocator> >
{
  static const char* value()
  {
    return "kaaican/can_std";
  }

  static const char* value(const ::kaaican::can_std_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::kaaican::can_std_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64 tosec\n"
"uint32 time\n"
"uint32 count\n"
"uint16 id\n"
"uint8 len\n"
"uint16[] data\n"
"uint16 status\n"
"uint16 aa\n"
"uint16 bb\n"
"uint16 cc\n"
"uint16 dd\n"
"uint16 ee\n"
"uint16 ff\n"
"uint16 gg\n"
"uint16 hh\n"
"uint16 ii\n"
"uint16 jj\n"
"uint16 kk\n"
"uint16 ll\n"
"uint16 mm\n"
"uint16 nn\n"
"uint16 oo\n"
"Header header\n"
"\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::kaaican::can_std_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::kaaican::can_std_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.tosec);
      stream.next(m.time);
      stream.next(m.count);
      stream.next(m.id);
      stream.next(m.len);
      stream.next(m.data);
      stream.next(m.status);
      stream.next(m.aa);
      stream.next(m.bb);
      stream.next(m.cc);
      stream.next(m.dd);
      stream.next(m.ee);
      stream.next(m.ff);
      stream.next(m.gg);
      stream.next(m.hh);
      stream.next(m.ii);
      stream.next(m.jj);
      stream.next(m.kk);
      stream.next(m.ll);
      stream.next(m.mm);
      stream.next(m.nn);
      stream.next(m.oo);
      stream.next(m.header);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct can_std_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::kaaican::can_std_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::kaaican::can_std_<ContainerAllocator>& v)
  {
    s << indent << "tosec: ";
    Printer<double>::stream(s, indent + "  ", v.tosec);
    s << indent << "time: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.time);
    s << indent << "count: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.count);
    s << indent << "id: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.id);
    s << indent << "len: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.len);
    s << indent << "data[]" << std::endl;
    for (size_t i = 0; i < v.data.size(); ++i)
    {
      s << indent << "  data[" << i << "]: ";
      Printer<uint16_t>::stream(s, indent + "  ", v.data[i]);
    }
    s << indent << "status: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.status);
    s << indent << "aa: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.aa);
    s << indent << "bb: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.bb);
    s << indent << "cc: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.cc);
    s << indent << "dd: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.dd);
    s << indent << "ee: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.ee);
    s << indent << "ff: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.ff);
    s << indent << "gg: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.gg);
    s << indent << "hh: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.hh);
    s << indent << "ii: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.ii);
    s << indent << "jj: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.jj);
    s << indent << "kk: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.kk);
    s << indent << "ll: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.ll);
    s << indent << "mm: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.mm);
    s << indent << "nn: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.nn);
    s << indent << "oo: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.oo);
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
  }
};

} // namespace message_operations
} // namespace ros

#endif // KAAICAN_MESSAGE_CAN_STD_H
